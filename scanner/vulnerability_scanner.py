import requests
from urllib.parse import urljoin
from scanner.utils import print_status

class VulnerabilityScanner:
    def __init__(self, target):
        self.target = target.rstrip("/")
        self.findings = []

    def run_all_tests(self):
        print_status(f"Starting scan on: {self.target}", "info")
        self.check_https()
        self.check_sql_injection()
        self.check_xss()
        self.check_http_headers()
        self.check_clickjacking()
        self.check_server_info_leak()
        self.check_directory_bruteforce()
        self.check_open_redirect()
        return self.findings

    # 1️⃣ Check for HTTPS usage
    def check_https(self):
        if not self.target.startswith("https://"):
            self.findings.append(("❌ Site does not use HTTPS", "High"))
            print_status("❌ Site is not using HTTPS – insecure", "warning")
        else:
            self.findings.append(("✅ Site uses HTTPS", "None"))
            print_status("✅ HTTPS is enabled", "info")

    # 2️⃣ SQL Injection
    def check_sql_injection(self):
        payload = "' OR '1'='1"
        try:
            r = requests.get(self.target, params={"id": payload}, timeout=5)
            if any(err in r.text.lower() for err in ["syntax", "mysql", "sql error"]):
                self.findings.append(("❌ SQL Injection vulnerability", "High"))
                print_status("❌ Possible SQL Injection found", "warning")
            else:
                self.findings.append(("✅ No SQL Injection detected", "None"))
                print_status("✅ No SQL Injection detected", "info")
        except Exception as e:
            print_status(f"Error testing SQLi: {e}", "error")

    # 3️⃣ XSS
    def check_xss(self):
        payload = "<script>alert(1)</script>"
        try:
            r = requests.get(self.target, params={"q": payload}, timeout=5)
            if payload in r.text:
                self.findings.append(("❌ Cross-Site Scripting (XSS)", "Medium"))
                print_status("❌ Possible XSS found", "warning")
            else:
                self.findings.append(("✅ No XSS detected", "None"))
                print_status("✅ No XSS detected", "info")
        except Exception as e:
            print_status(f"Error testing XSS: {e}", "error")

    # 4️⃣ Missing Security Headers
    def check_http_headers(self):
        try:
            r = requests.get(self.target, timeout=5)
            missing_headers = []
            headers_to_check = [
                "Content-Security-Policy",
                "X-Frame-Options",
                "Strict-Transport-Security"
            ]
            for header in headers_to_check:
                if header not in r.headers:
                    missing_headers.append(header)
            if missing_headers:
                self.findings.append((f"❌ Missing Security Headers: {', '.join(missing_headers)}", "Low"))
                print_status(f"❌ Missing headers: {', '.join(missing_headers)}", "warning")
            else:
                self.findings.append(("✅ All security headers present", "None"))
                print_status("✅ All important security headers present", "info")
        except Exception as e:
            print_status(f"Error checking headers: {e}", "error")

    # 5️⃣ Clickjacking
    def check_clickjacking(self):
        try:
            r = requests.get(self.target, timeout=5)
            if "X-Frame-Options" not in r.headers:
                self.findings.append(("❌ No Clickjacking Protection", "Medium"))
                print_status("❌ Site vulnerable to clickjacking", "warning")
            else:
                self.findings.append(("✅ Clickjacking protection enabled", "None"))
                print_status("✅ Clickjacking protection enabled", "info")
        except Exception as e:
            print_status(f"Error checking clickjacking: {e}", "error")

    # 6️⃣ Server Info Leakage
    def check_server_info_leak(self):
        try:
            r = requests.get(self.target, timeout=5)
            if "Server" in r.headers:
                self.findings.append((f"❌ Server Info Leaked: {r.headers['Server']}", "Low"))
                print_status(f"❌ Server info leaked: {r.headers['Server']}", "warning")
            else:
                self.findings.append(("✅ No server info leakage", "None"))
                print_status("✅ No server info leakage", "info")
        except Exception as e:
            print_status(f"Error checking server info: {e}", "error")

    # 7️⃣ Directory Brute Force
    def check_directory_bruteforce(self):
        paths = ["admin", "login", "config.php", "backup.zip", ".env"]
        found_any = False
        for path in paths:
            url = urljoin(self.target + "/", path)
            try:
                r = requests.get(url, timeout=5)
                if r.status_code == 200:
                    self.findings.append((f"❌ Accessible File/Dir: {url}", "Medium"))
                    print_status(f"❌ Found sensitive path: {url}", "warning")
                    found_any = True
            except Exception as e:
                print_status(f"Error checking path {path}: {e}", "error")
        if not found_any:
            self.findings.append(("✅ No sensitive directories/files found", "None"))
            print_status("✅ No sensitive directories/files found", "info")

    # 8️⃣ Open Redirect
    def check_open_redirect(self):
        test_param = "redirect"
        payload_url = "https://evil.com"
        try:
            r = requests.get(self.target, params={test_param: payload_url}, allow_redirects=False, timeout=5)
            if r.status_code in [301, 302] and payload_url in r.headers.get("Location", ""):
                self.findings.append(("❌ Open Redirect", "Medium"))
                print_status("❌ Possible Open Redirect found", "warning")
            else:
                self.findings.append(("✅ No Open Redirect detected", "None"))
                print_status("✅ No Open Redirect detected", "info")
        except Exception as e:
            print_status(f"Error checking open redirect: {e}", "error")
